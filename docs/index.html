<html>
  <head>
    <title>CAPABLANCA</title>
    <style>
      body {
        background-color: black;
        color: white;
      }
      code:not(.language-diff) {
        background-color: #f0f0f0; /* Light gray background */
        color: black;
        display: inline-block;
      }
      code.language-diff {
        background-color: while;
        color: green;
      }
      /* Basic styling for bash commands */
      .language-bash {
        color: #0000ff !important; /* Blue command */
        font-family: monospace; /* Monospace font for code */
        padding: 10px;
        border-radius: 5px;
        overflow-x: auto; /* Horizontal scrolling if needed */
        font-size: 14px; /* Adjust as needed */
        line-height: 1.4;
        font-weight: bold;
        margin-bottom: 10px;
      }
    </style>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js"],
        "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
        TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
        messageStyle: "none"
      });
    </script>
    <script
      type="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"
    ></script>
  </head>
  <body>
    <h1>Capablanca: Minimum Vertex Cover Solver</h1>
    <p>
      <img
        src="capablanca.jpg"
        alt="Honoring the Memory of Jose Raul Capablanca (Third World Chess Champion from 1921 to 1927)"
      />
    </p>
    <p>
      This work builds upon
      <a
        href="https://www.researchgate.net/publication/388420196_The_Minimum_Vertex_Cover_Problem"
        >The Minimum Vertex Cover Problem</a
      >.
    </p>
    <hr />
    <h1>The Minimum Vertex Cover Problem</h1>
    <p>
      The Minimum Vertex Cover (MVC) problem is a classic optimization problem
      in computer science and graph theory. It deals with finding the smallest
      set of vertices in a graph that <code>covers</code> all the edges. This
      means that for every edge in the graph, at least one of its endpoints must
      be in the chosen set of vertices.
    </p>
    <h2>Formal Definition</h2>
    <p>
      Given an undirected graph $G = (V, E)$, where $V$ is the set of vertices
      and $E$ is the set of edges, a vertex cover is a subset $V' \subseteq V$
      such that for every edge $(u, v) \in E$, at least one of the vertices $u$
      or $v$ belongs to $V'$. The Minimum Vertex Cover problem aims to find a
      vertex cover $V'$ with the smallest possible cardinality (i.e., the fewest
      number of vertices).
    </p>
    <h2>Importance and Applications</h2>
    <p>The Minimum Vertex Cover problem is important for several reasons:</p>
    <ul>
      <li>
        <strong>Theoretical Significance:</strong> It is a well-studied NP-hard
        problem, meaning that no known algorithm can solve it optimally for all
        instances in polynomial time. This makes it a crucial problem in
        complexity theory.
      </li>
      <li>
        <strong>Practical Applications:</strong> It has applications in various
        fields, including:
        <ul>
          <li>
            <strong>Network security:</strong> Finding critical nodes in a
            network that, if compromised, would disrupt connections.
          </li>
          <li>
            <strong>Bioinformatics:</strong> Identifying important genes in gene
            regulatory networks.
          </li>
          <li>
            <strong>Wireless sensor networks:</strong> Determining the minimum
            number of sensors needed to monitor a given area.
          </li>
        </ul>
      </li>
    </ul>
    <h2>Related Problems</h2>
    <p>
      The Minimum Vertex Cover problem is closely related to other graph
      problems, such as:
    </p>
    <ul>
      <li>
        <strong>Maximum Independent Set:</strong> A set of vertices where no two
        vertices are adjacent. The size of the minimum vertex cover plus the
        size of the maximum independent set is equal to the total number of
        vertices in the graph.
      </li>
      <li>
        <strong>Set Cover Problem:</strong> A more general problem where sets of
        elements are used to cover a universe of elements.
      </li>
    </ul>
    <hr />
    <h1>Our Algorithm - Runtime $O(n^{2} \cdot m)$</h1>
    <h2>The algorithm explanation:</h2>
    <p>The algorithm works as follows:</p>
    <ol>
      <li>
        <p>
          It takes a sparse adjacency matrix as input and converts it into a
          graph.
        </p>
      </li>
      <li>
        <p>It decomposes the graph into connected components.</p>
      </li>
      <li>
        <p>
          For each connected component, it computes a minimum edge cut and
          selects one of the two candidate vertex sets (based on their degrees)
          to add to the vertex cover.
        </p>
      </li>
      <li>
        <p>It repeats this process until all edges are covered.</p>
      </li>
    </ol>
    <h2>Correctness</h2>
    <p>
      The algorithm guarantees that every edge in the graph is covered by the
      computed vertex cover. This is achieved through the following steps:
    </p>
    <ol>
      <li>
        <p>
          The algorithm processes each connected component of the graph
          iteratively. This ensures that all parts of the graph are considered,
          even if the graph is disconnected.
        </p>
      </li>
      <li>
        <p>
          For each connected component, the algorithm computes a minimum edge
          cut. The vertices involved in this cut are added to the vertex cover,
          ensuring that all edges in the cut are covered.
        </p>
      </li>
      <li>
        <p>
          After adding the vertices of the cut to the cover, the algorithm
          removes these vertices from the graph. This step eliminates all edges
          incident to the selected vertices, ensuring they are fully covered.
        </p>
      </li>
      <li>
        <p>
          The process repeats on the remaining subgraph until no edges are left.
          This iterative approach guarantees that every edge in the original
          graph is incident to at least one vertex in the final cover.
        </p>
      </li>
    </ol>
    <p>
      By systematically processing each connected component and leveraging the
      properties of minimum edge cuts, the algorithm constructs a valid vertex
      cover that satisfies the problem's requirements.
    </p>
    <h2>Runtime Analysis</h2>
    <p>The algorithm runs in polynomial time because:</p>
    <ol>
      <li>
        <p>
          Converting the sparse adjacency matrix to edges takes $O(m)$ time,
          where $m$ is the number of edges.
        </p>
      </li>
      <li>
        <p>
          Constructing the graph using <code>nx.Graph</code> takes $O(m)$ time.
        </p>
      </li>
      <li>
        <p>
          The <code>nx.connected_components</code> function runs in $O(n + m)$
          time, where $n$ is the number of vertices.
        </p>
      </li>
      <li>
        <p>
          The <code>nx.minimum_edge_cut</code> function uses the shortest
          augmenting path algorithm, which runs in $O(n \cdot m)$ time.
        </p>
      </li>
      <li>
        <p>
          The outer loop iterates over connected components, and each iteration
          processes a subset of the graph. The total number of iterations is
          bounded by the number of connected components, which is at most $n$.
        </p>
      </li>
    </ol>
    <p>
      Thus, the overall time complexity is polynomial in the size of the input
      graph (i.e., $O(n^{2} \cdot m)$).
    </p>
    <hr />
    <h1>Compile and Environment</h1>
    <h2>Install Python &gt;=3.10.</h2>
    <h2>Install Capablanca's Library and its Dependencies with:</h2>
    <pre><code class="language-bash">pip install capablanca
</code></pre>
    <h1>Execute</h1>
    <ol>
      <li>Go to the package directory to use the benchmarks:</li>
    </ol>
    <pre><code class="language-bash">git clone https://github.com/frankvegadelgado/capablanca.git
cd capablanca
</code></pre>
    <ol start="2">
      <li>Execute the script:</li>
    </ol>
    <pre><code class="language-bash">cover -i .\benchmarks\testMatrix1.txt
</code></pre>
    <p>
      utilizing the <code>cover</code> command provided by Capablanca's Library
      to execute the Boolean adjacency matrix
      <code>capablanca\benchmarks\testMatrix1.txt</code>. We also support .xz,
      .lzma, .bz2, and .bzip2 compressed .txt files.
    </p>
    <h2>The console output will display:</h2>
    <pre><code>testMatrix1.txt: Vertex Cover Found 2, 3, 4
</code></pre>
    <p>
      which implies that the Boolean adjacency matrix
      <code>capablanca\benchmarks\testMatrix1.txt</code> contains a vertex cover
      of nodes <code>2, 3, 4</code>.
    </p>
    <hr />
    <h2>Size of the Approximate Vertex Cover - Polynomial Runtime</h2>
    <p>
      The <code>-c</code> flag counts the nodes in the approximate vertex cover.
    </p>
    <p><strong>Example:</strong></p>
    <pre><code class="language-bash">cover -i .\benchmarks\testMatrix2.txt -c
</code></pre>
    <p><strong>Output:</strong></p>
    <pre><code>testMatrix2.txt: Vertex Cover Size 5
</code></pre>
    <h2>Runtime Analysis:</h2>
    <p>We employ the same algorithm used to find vertex cover set.</p>
    <hr />
    <h1>Command Options</h1>
    <p>
      To display the help message and available options, run the following
      command in your terminal:
    </p>
    <pre><code class="language-bash">cover -h
</code></pre>
    <p>This will output:</p>
    <pre><code>usage: cover [-h] -i INPUTFILE [-a] [-b] [-c] [-v] [-l] [--version]

Approximating the Minimum Vertex Cover within a factor of less than sqrt(2) for an undirected graph represented by a Boolean
adjacency matrix in a file.

options:
  -h, --help            show this help message and exit
  -i INPUTFILE, --inputFile INPUTFILE
                        input file path
  -a, --approximation   enable comparison with a polynomial-time approximation approach within a factor of 2
  -b, --bruteForce      enable comparison with the exponential-time brute-force approach
  -c, --count           calculate the size of the vertex cover
  -v, --verbose         anable verbose output
  -l, --log             enable file logging
  --version             show program's version number and exit
</code></pre>
    <p>This output describes all available options.</p>
    <h2>The Capablanca Testing Application</h2>
    <p>
      A command-line tool, <code>test_cover</code>, has been developed for
      testing algorithms on randomly generated, large sparse matrices. It
      accepts the following options:
    </p>
    <pre><code>usage: test_cover [-h] -d DIMENSION [-n NUM_TESTS] [-s SPARSITY] [-a] [-b] [-c] [-w] [-v] [-l] [--version]

The Capablanca Testing Application.

options:
  -h, --help            show this help message and exit
  -d DIMENSION, --dimension DIMENSION
                        an integer specifying the dimensions of the square matrices
  -n NUM_TESTS, --num_tests NUM_TESTS
                        an integer specifying the number of tests to run
  -s SPARSITY, --sparsity SPARSITY
                        sparsity of the matrices (0.0 for dense, close to 1.0 for very sparse)
  -a, --approximation   enable comparison with a polynomial-time approximation approach within a factor of 2
  -b, --bruteForce      enable comparison with the exponential-time brute-force approach
  -c, --count           calculate the size of the vertex cover
  -w, --write           write the generated random matrix to a file in the current directory
  -v, --verbose         anable verbose output
  -l, --log             enable file logging
  --version             show program's version number and exit
</code></pre>
    <p>
      <strong
        >This tool is designed to benchmark algorithms for sparse matrix
        operations.</strong
      >
    </p>
    <p>
      It generates random square matrices with configurable dimensions
      (<code>-d</code>), sparsity levels (<code>-s</code>), and number of tests
      (<code>-n</code>). Brute-force and heuristic comparisons are available but
      not recommended for large datasets due to performance issues.
      Additionally, the generated matrix can be written to the current directory
      (<code>-w</code>), and verbose output or file logging can be enabled with
      the (<code>-v</code>) or (<code>-l</code>) flag, respectively, to record
      test results.
    </p>
    <hr />
    <h1>Code</h1>
    <ul>
      <li>Python code by <strong>Frank Vega</strong>.</li>
    </ul>
    <hr />
    <h1>Complexity</h1>
    <pre><code class="language-diff">+ We present a polynomial-time algorithm achieving an approximation ratio below sqrt(2) for the minimum vertex cover, providing strong evidence that P = NP by efficiently solving a computationally hard problem with near-optimal solutions.

+ This result contradicts the Unique Games Conjecture, which predicts such improvements are impossible, thereby undermining UGC and reshaping our understanding of hardness of approximation.

+ The algorithm not only solves a long-standing open problem but also suggests that many other optimization problems might admit better solutions, revolutionizing theoretical computer science.
</code></pre>
    <hr />
    <h1>License</h1>
    <ul>
      <li>MIT.</li>
    </ul>
  </body>
</html>
